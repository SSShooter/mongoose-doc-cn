<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Mongoose v5.0.15: Schemas</title><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"><link rel="stylesheet" href="/docs/css/github.css"><link rel="stylesheet" href="/docs/css/mongoose5.css"><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="manifest" href="images/favicon/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="images/favicon/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"></head><body><div id="layout"><div id="mobile-menu"><a id="menuLink" href="#menu" class="menu-link"><span></span></a><div id="mobile-logo-container"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div></div><div id="menu"><div class="pure-menu"><div id="logo-container" class="pure-menu-heading"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div><ul class="pure-menu-list"><li class="pure-menu-horizontal pure-menu-item pure-menu-has-children pure-menu-allow-hover version"><a href="#" class="pure-menu-link">Version 5.0.15</a><ul class="pure-menu-children"><li class="pure-menu-item"><a href="/docs/4.x" class="pure-menu-link">Version 4.13.12</a></li><li class="pure-menu-item"><a href="/docs/3.8.x" class="pure-menu-link">Version 3.8.40</a></li></ul></li><li class="pure-menu-item"><a href="/docs/index.html" class="pure-menu-link">Quick Start</a></li><li class="pure-menu-item"><a href="/docs/guide.html" class="pure-menu-link">Schemas</a></li><li class="pure-menu-item sub-item"><a href="/docs/schematypes.html" class="pure-menu-link">SchemaTypes</a></li><li class="pure-menu-item sub-item"><a href="/docs/connections.html" class="pure-menu-link">Connections</a></li><li class="pure-menu-item sub-item"><a href="/docs/models.html" class="pure-menu-link">Models</a></li><li class="pure-menu-item sub-item"><a href="/docs/documents.html" class="pure-menu-link">Documents</a></li><li class="pure-menu-item sub-item"><a href="/docs/subdocs.html" class="pure-menu-link">Subdocuments</a></li><li class="pure-menu-item sub-item"><a href="/docs/queries.html" class="pure-menu-link">Queries</a></li><li class="pure-menu-item sub-item"><a href="/docs/validation.html" class="pure-menu-link">Validation</a></li><li class="pure-menu-item sub-item"><a href="/docs/middleware.html" class="pure-menu-link">Middleware</a></li><li class="pure-menu-item sub-item"><a href="/docs/populate.html" class="pure-menu-link">Populate</a></li><li class="pure-menu-item sub-item"><a href="/docs/discriminators.html" class="pure-menu-link">Discriminators</a></li><li class="pure-menu-item sub-item"><a href="/docs/plugins.html" class="pure-menu-link">Plugins</a></li><li class="pure-menu-item sub-item"><a href="/docs/lambda.html" class="pure-menu-link">AWS Lambda</a></li><li class="pure-menu-item"><a href="/docs/api.html" class="pure-menu-link">API</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Schema" class="pure-menu-link">Schema</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Connection" class="pure-menu-link">Connection</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Document" class="pure-menu-link">Document</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Model" class="pure-menu-link">Model</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Query" class="pure-menu-link">Query</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Aggregate" class="pure-menu-link">Aggregate</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Schematype" class="pure-menu-link">SchemaType</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Virtualtype" class="pure-menu-link">VirtualType</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Error" class="pure-menu-link">Error</a></li><li class="pure-menu-item"><a href="/docs/compatibility.html" class="pure-menu-link">Version Compatibility</a></li><li class="pure-menu-item"><a href="/docs/faq.html" class="pure-menu-link">FAQ</a></li><li class="carbon-ad"><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=mongoosejscom" id="_carbonads_js"></script></li></ul></div></div><div class="container"><div id="content"><h2>Schemas</h2><div class="important"><p>建议先阅读<a href="./index.html">快速上手</a>，简单了解一下Mongoose的工作流程。
如果你要从4.x迁移到5.x，请阅读<a href="https://github.com/Automattic/mongoose/blob/master/migrating_to_5.md">迁移指引</a>.</p>
</div><h3 id="definition"><a href="#definition">定义一个schema</a></h3>

<p>Mongoose 的一切始于 Schema。每个 schema 都会映射到一个 MongoDB
collection ，并定义这个collection里的文档的构成。</p>
<pre><code class="lang-javascript">  <span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
  <span class="hljs-keyword">var</span> Schema = mongoose.Schema;

  <span class="hljs-keyword">var</span> blogSchema = <span class="hljs-keyword">new</span> Schema({
    title:  <span class="hljs-built_in">String</span>,
    author: <span class="hljs-built_in">String</span>,
    body:   <span class="hljs-built_in">String</span>,
    comments: [{ body: <span class="hljs-built_in">String</span>, date: <span class="hljs-built_in">Date</span> }],
    date: { type: <span class="hljs-built_in">Date</span>, <span class="hljs-keyword">default</span>: <span class="hljs-built_in">Date</span>.now },
    hidden: <span class="hljs-built_in">Boolean</span>,
    meta: {
      votes: <span class="hljs-built_in">Number</span>,
      favs:  <span class="hljs-built_in">Number</span>
    }
  });
</code></pre>
<p>在这之后你还想添加 keys 的话， 请使用
<a href="./api.html#schema_Schema-add">Schema#add</a> 方法。</p>
<p>Each key in our code <code>blogSchema</code> defines a property in our documents which
will be cast to its associated <a href="./api.html#schematype_SchemaType">SchemaType</a>.
For example, we&#39;ve defined a property <code>title</code> which will be cast to the
<a href="./api.html#schema-string-js">String</a> SchemaType and property <code>date</code>
which will be cast to a <code>Date</code> SchemaType. Keys may also be assigned
nested objects containing further key/type definitions like
the <code>meta</code> property above.</p>
<p>The permitted SchemaTypes are:</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Date</li>
<li>Buffer</li>
<li>Boolean</li>
<li>Mixed</li>
<li>ObjectId</li>
<li>Array</li>
</ul>
<p>Read more about <a href="./schematypes.html">SchemaTypes here</a>.</p>
<p>Schemas not only define the structure of your document and casting of
properties, they also define document <a href="#methods">instance methods</a>,
<a href="#statics">static Model methods</a>, <a href="#indexes">compound indexes</a>,
and document lifecycle hooks called <a href="./middleware.html">middleware</a>.</p>
<h3 id="models"><a href="#models">Creating a model</a></h3>

<p>To use our schema definition, we need to convert our <code>blogSchema</code> into a
<a href="./models.html">Model</a> we can work with.
To do so, we pass it into <code>mongoose.model(modelName, schema)</code>:</p>
<pre><code class="lang-javascript">  <span class="hljs-keyword">var</span> Blog = mongoose.model(<span class="hljs-string">'Blog'</span>, blogSchema);
  <span class="hljs-comment">// ready to go!</span>
</code></pre>
<h3 id="methods"><a href="#methods">Instance methods</a></h3>

<p>Instances of <code>Models</code> are <a href="./documents.html">documents</a>. Documents have
many of their own <a href="./api.html#document-js">built-in instance methods</a>.
We may also define our own custom document instance methods too.</p>
<pre><code class="lang-javascript">  <span class="hljs-comment">// define a schema</span>
  <span class="hljs-keyword">var</span> animalSchema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span>, type: <span class="hljs-built_in">String</span> });

  <span class="hljs-comment">// assign a function to the "methods" object of our animalSchema</span>
  animalSchema.methods.findSimilarTypes = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.model(<span class="hljs-string">'Animal'</span>).find({ type: <span class="hljs-keyword">this</span>.type }, cb);
  };
</code></pre>
<p>Now all of our <code>animal</code> instances have a <code>findSimilarTypes</code> method available
to them.</p>
<pre><code class="lang-javascript">  <span class="hljs-keyword">var</span> Animal = mongoose.model(<span class="hljs-string">'Animal'</span>, animalSchema);
  <span class="hljs-keyword">var</span> dog = <span class="hljs-keyword">new</span> Animal({ type: <span class="hljs-string">'dog'</span> });

  dog.findSimilarTypes(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, dogs</span>) </span>{
    <span class="hljs-built_in">console</span>.log(dogs); <span class="hljs-comment">// woof</span>
  });
</code></pre>
<ul>
<li>Overwriting a default mongoose document method may lead to unpredictable results. See <a href="./api.html#schema_Schema.reserved">this</a> for more details.</li>
<li>Do <strong>not</strong> declare methods using ES6 arrow functions (<code>=&gt;</code>). Arrow functions <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this">explicitly prevent binding <code>this</code></a>, so your method will <strong>not</strong> have access to the document and the above examples will not work.</li>
</ul>
<h3 id="statics"><a href="#statics">Statics</a></h3>

<p>Adding static methods to a <code>Model</code> is simple as well. Continuing with our
<code>animalSchema</code>:</p>
<pre><code class="lang-javascript">  <span class="hljs-comment">// assign a function to the "statics" object of our animalSchema</span>
  animalSchema.statics.findByName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, cb</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.find({ name: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(name, <span class="hljs-string">'i'</span>) }, cb);
  };

  <span class="hljs-keyword">var</span> Animal = mongoose.model(<span class="hljs-string">'Animal'</span>, animalSchema);
  Animal.findByName(<span class="hljs-string">'fido'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, animals</span>) </span>{
    <span class="hljs-built_in">console</span>.log(animals);
  });
</code></pre>
<p>Do <strong>not</strong> declare statics using ES6 arrow functions (<code>=&gt;</code>). Arrow functions <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this">explicitly prevent binding <code>this</code></a>, so the above examples will not work because of the value of <code>this</code>.</p>
<h3 id="query-helpers"><a href="#query-helpers">Query Helpers</a></h3>

<p>You can also add query helper functions, which are like instance methods
but for mongoose queries. Query helper methods let you extend mongoose&#39;s
<a href="./queries.html">chainable query builder API</a>.</p>
<pre><code class="lang-javascript">  animalSchema.query.byName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.find({ name: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(name, <span class="hljs-string">'i'</span>) });
  };

  <span class="hljs-keyword">var</span> Animal = mongoose.model(<span class="hljs-string">'Animal'</span>, animalSchema);
  Animal.find().byName(<span class="hljs-string">'fido'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, animals</span>) </span>{
    <span class="hljs-built_in">console</span>.log(animals);
  });
</code></pre>
<h3 id="indexes"><a href="#indexes">Indexes</a></h3>

<p>MongoDB supports <a href="http://docs.mongodb.org/manual/indexes/">secondary indexes</a>.
With mongoose, we define these indexes within our <code>Schema</code> <a href="./api.html#schematype_SchemaType-index">at</a> <a href="./api.html#schematype_SchemaType-unique">the</a> <a href="./api.html#schematype_SchemaType-sparse">path</a> <a href="./api.html#schema_date_SchemaDate-expires">level</a> or the <code>schema</code> level.
Defining indexes at the schema level is necessary when creating
<a href="https://docs.mongodb.com/manual/core/index-compound/">compound indexes</a>.</p>
<pre><code class="lang-javascript">  <span class="hljs-keyword">var</span> animalSchema = <span class="hljs-keyword">new</span> Schema({
    name: <span class="hljs-built_in">String</span>,
    type: <span class="hljs-built_in">String</span>,
    tags: { type: [<span class="hljs-built_in">String</span>], index: <span class="hljs-literal">true</span> } <span class="hljs-comment">// field level</span>
  });

  animalSchema.index({ name: <span class="hljs-number">1</span>, type: <span class="hljs-number">-1</span> }); <span class="hljs-comment">// schema level</span>
</code></pre>
<p>When your application starts up, Mongoose automatically calls <a href="https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#db.collection.createIndex"><code>createIndex</code></a> for each defined index in your schema.
Mongoose will call <code>createIndex</code> for each index sequentially, and emit an &#39;index&#39; event on the model when all the <code>createIndex</code> calls succeeded or when there was an error.
While nice for development, it is recommended this behavior be disabled in production since index creation can cause a <a href="http://docs.mongodb.org/manual/core/indexes/#index-creation-operations">significant performance impact</a>. Disable the behavior by setting the <code>autoIndex</code> option of your schema to <code>false</code>, or globally on the connection by setting the option <code>autoIndex</code> to <code>false</code>.</p>
<pre><code class="lang-javascript">  mongoose.connect(<span class="hljs-string">'mongodb://user:pass@localhost:port/database'</span>, { autoIndex: <span class="hljs-literal">false</span> });
  <span class="hljs-comment">// or</span>
  mongoose.createConnection(<span class="hljs-string">'mongodb://user:pass@localhost:port/database'</span>, { autoIndex: <span class="hljs-literal">false</span> });
  <span class="hljs-comment">// or</span>
  animalSchema.set(<span class="hljs-string">'autoIndex'</span>, <span class="hljs-literal">false</span>);
  <span class="hljs-comment">// or</span>
  <span class="hljs-keyword">new</span> Schema({..}, { autoIndex: <span class="hljs-literal">false</span> });
</code></pre>
<p>Mongoose will emit an <code>index</code> event on the model when indexes are done
building or an error occurred.</p>
<pre><code class="lang-javascript">  <span class="hljs-comment">// Will cause an error because mongodb has an _id index by default that</span>
  <span class="hljs-comment">// is not sparse</span>
  animalSchema.index({ _id: <span class="hljs-number">1</span> }, { sparse: <span class="hljs-literal">true</span> });
  <span class="hljs-keyword">var</span> Animal = mongoose.model(<span class="hljs-string">'Animal'</span>, animalSchema);

  Animal.on(<span class="hljs-string">'index'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
    <span class="hljs-comment">// "_id index cannot be sparse"</span>
    <span class="hljs-built_in">console</span>.log(error.message);
  });
</code></pre>
<p>See also the <a href="./api.html#model_Model.ensureIndexes">Model#ensureIndexes</a> method.</p>
<h3 id="virtuals"><a href="#virtuals">Virtuals</a></h3>

<p><a href="./api.html#schema_Schema-virtual">Virtuals</a> are document properties that
you can get and set but that do not get persisted to MongoDB. The getters
are useful for formatting or combining fields, while setters are useful for
de-composing a single value into multiple values for storage.</p>
<pre><code class="lang-javascript">  <span class="hljs-comment">// define a schema</span>
  <span class="hljs-keyword">var</span> personSchema = <span class="hljs-keyword">new</span> Schema({
    name: {
      first: <span class="hljs-built_in">String</span>,
      last: <span class="hljs-built_in">String</span>
    }
  });

  <span class="hljs-comment">// compile our model</span>
  <span class="hljs-keyword">var</span> Person = mongoose.model(<span class="hljs-string">'Person'</span>, personSchema);

  <span class="hljs-comment">// create a document</span>
  <span class="hljs-keyword">var</span> axl = <span class="hljs-keyword">new</span> Person({
    name: { first: <span class="hljs-string">'Axl'</span>, last: <span class="hljs-string">'Rose'</span> }
  });
</code></pre>
<p>Suppose you want to print out the person&#39;s full name. You could do it yourself:</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">console</span>.log(axl.name.first + <span class="hljs-string">' '</span> + axl.name.last); <span class="hljs-comment">// Axl Rose</span>
</code></pre>
<p>But concatenating the first and last name every time can get cumbersome.
And what if you want to do some extra processing on the name, like
<a href="https://www.npmjs.com/package/diacritics">removing diacritics</a>? A
<a href="./api.html#virtualtype_VirtualType-get">virtual property getter</a> lets you</p>
<p>define a <code>fullName</code> property that won&#39;t get persisted to MongoDB.</p>
<pre><code class="lang-javascript">personSchema.virtual(<span class="hljs-string">'fullName'</span>).get(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.first + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.name.last;
});
</code></pre>
<p>Now, mongoose will call your getter function every time you access the
<code>fullName</code> property:</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">console</span>.log(axl.fullName); <span class="hljs-comment">// Axl Rose</span>
</code></pre>
<p>If you use <code>toJSON()</code> or <code>toObject()</code> (or use <code>JSON.stringify()</code> on a
mongoose document) mongoose will <em>not</em> include virtuals by default.
Pass <code>{ virtuals: true }</code> to either
<a href="./api.html#document_Document-toObject">toObject()</a> or <code>toJSON()</code>.</p>
<p>You can also add a custom setter to your virtual that will let you set both
first name and last name via the <code>fullName</code> virtual.</p>
<pre><code class="lang-javascript">personSchema.virtual(<span class="hljs-string">'fullName'</span>).
  get(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.first + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.name.last; }).
  set(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
    <span class="hljs-keyword">this</span>.name.first = v.substr(<span class="hljs-number">0</span>, v.indexOf(<span class="hljs-string">' '</span>));
    <span class="hljs-keyword">this</span>.name.last = v.substr(v.indexOf(<span class="hljs-string">' '</span>) + <span class="hljs-number">1</span>);
  });

axl.fullName = <span class="hljs-string">'William Rose'</span>; <span class="hljs-comment">// Now `axl.name.first` is "William"</span>
</code></pre>
<p>Virtual property setters are applied before other validation. So the example
above would still work even if the <code>first</code> and <code>last</code> name fields were
required.</p>
<p>Only non-virtual properties work as part of queries and for field selection.
Since virtuals are not stored in MongoDB, you can&#39;t query with them.</p>
<h5 id="aliases"><a href="#aliases">Aliases</a></h5>

<p>Aliases are a particular type of virtual where the getter and setter
seamlessly get and set another property. This is handy for saving network
bandwidth, so you can convert a short property name stored in the database
into a longer name for code readability.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> personSchema = <span class="hljs-keyword">new</span> Schema({
  n: {
    type: <span class="hljs-built_in">String</span>,
    <span class="hljs-comment">// Now accessing `name` will get you the value of `n`, and setting `n` will set the value of `name`</span>
    alias: <span class="hljs-string">'name'</span>
  }
});

<span class="hljs-comment">// Setting `name` will propagate to `n`</span>
<span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person({ name: <span class="hljs-string">'Val'</span> });
<span class="hljs-built_in">console</span>.log(person); <span class="hljs-comment">// { n: 'Val' }</span>
<span class="hljs-built_in">console</span>.log(person.toObject({ virtuals: <span class="hljs-literal">true</span> })); <span class="hljs-comment">// { n: 'Val', name: 'Val' }</span>
<span class="hljs-built_in">console</span>.log(person.name); <span class="hljs-comment">// "Val"</span>

person.name = <span class="hljs-string">'Not Val'</span>;
<span class="hljs-built_in">console</span>.log(person); <span class="hljs-comment">// { n: 'Not Val' }</span>
</code></pre>
<h3 id="options"><a href="#options">Options</a></h3>

<p>Schemas have a few configurable options which can be passed to the
constructor or <code>set</code> directly:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({..}, options);

<span class="hljs-comment">// or</span>

<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..});
schema.set(option, value);
</code></pre>
<p>Valid options:</p>
<ul>
<li><a href="#autoIndex">autoIndex</a></li>
<li><a href="#bufferCommands">bufferCommands</a></li>
<li><a href="#capped">capped</a></li>
<li><a href="#collection">collection</a></li>
<li><a href="#id">id</a></li>
<li><a href="#_id">_id</a></li>
<li><a href="#minimize">minimize</a></li>
<li><a href="#read">read</a></li>
<li><a href="#shardKey">shardKey</a></li>
<li><a href="#strict">strict</a></li>
<li><a href="#strictQuery">strictQuery</a></li>
<li><a href="#toJSON">toJSON</a></li>
<li><a href="#toObject">toObject</a></li>
<li><a href="#typeKey">typeKey</a></li>
<li><a href="#validateBeforeSave">validateBeforeSave</a></li>
<li><a href="#versionKey">versionKey</a></li>
<li><a href="#collation">collation</a></li>
<li><a href="#skipVersioning">skipVersioning</a></li>
<li><a href="#timestamps">timestamps</a></li>
</ul>
<h3 id="autoIndex"><a href="#autoIndex">option: autoIndex</a></h3>

<p>At application startup, Mongoose sends a <a href="https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#db.collection.createIndex"><code>createIndex</code> command</a> for each index declared in your <code>Schema</code>. As of Mongoose v3, indexes are created in the <code>background</code> by default. If you wish to disable the auto-creation feature and manually handle when indexes are created, set your <code>Schema</code>s <code>autoIndex</code> option to <code>false</code> and use the <a href="./api.html#model_Model.ensureIndexes">ensureIndexes</a> method on your model.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { autoIndex: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> Clock = mongoose.model(<span class="hljs-string">'Clock'</span>, schema);
Clock.ensureIndexes(callback);
</code></pre>
<h3 id="bufferCommands"><a href="#bufferCommands">option: bufferCommands</a></h3>

<p>By default, mongoose buffers commands when the connection goes down until
the driver manages to reconnect. To disable buffering, set <code>bufferCommands</code>
to false.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { bufferCommands: <span class="hljs-literal">false</span> });
</code></pre>
<p>The schema <code>bufferCommands</code> option overrides the global <code>bufferCommands</code> option.</p>
<pre><code class="lang-javascript">mongoose.set(<span class="hljs-string">'bufferCommands'</span>, <span class="hljs-literal">true</span>);
<span class="hljs-comment">// Schema option below overrides the above, if the schema option is set.</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { bufferCommands: <span class="hljs-literal">false</span> });
</code></pre>
<h3 id="capped"><a href="#capped">option: capped</a></h3>

<p>Mongoose supports MongoDBs <a href="http://www.mongodb.org/display/DOCS/Capped+Collections">capped</a>
collections. To specify the underlying MongoDB collection be <code>capped</code>, set
the <code>capped</code> option to the maximum size of the collection in
<a href="http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-size.">bytes</a>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({..}, { capped: <span class="hljs-number">1024</span> });
</code></pre>
<p>The <code>capped</code> option may also be set to an object if you want to pass
additional options like <a href="http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-max">max</a>
or <a href="http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-autoIndexId">autoIndexId</a>.
In this case you must explicitly pass the <code>size</code> option, which is required.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({..}, { capped: { size: <span class="hljs-number">1024</span>, max: <span class="hljs-number">1000</span>, autoIndexId: <span class="hljs-literal">true</span> } });
</code></pre>
<h3 id="collection"><a href="#collection">option: collection</a></h3>

<p>Mongoose by default produces a collection name by passing the model name to
the <a href="./api.html#utils_exports.toCollectionName">utils.toCollectionName</a> method.
This method pluralizes the name. Set this option if you need a different name
for your collection.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> dataSchema = <span class="hljs-keyword">new</span> Schema({..}, { collection: <span class="hljs-string">'data'</span> });
</code></pre>
<h3 id="id"><a href="#id">option: id</a></h3>

<p>Mongoose assigns each of your schemas an <code>id</code> virtual getter by default
which returns the documents <code>_id</code> field cast to a string, or in the case of
ObjectIds, its hexString. If you don&#39;t want an <code>id</code> getter added to your
schema, you may disable it passing this option at schema construction time.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// default behavior</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
<span class="hljs-keyword">var</span> Page = mongoose.model(<span class="hljs-string">'Page'</span>, schema);
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Page({ name: <span class="hljs-string">'mongodb.org'</span> });
<span class="hljs-built_in">console</span>.log(p.id); <span class="hljs-comment">// '50341373e894ad16347efe01'</span>

<span class="hljs-comment">// disabled id</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> }, { id: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> Page = mongoose.model(<span class="hljs-string">'Page'</span>, schema);
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Page({ name: <span class="hljs-string">'mongodb.org'</span> });
<span class="hljs-built_in">console</span>.log(p.id); <span class="hljs-comment">// undefined</span>
</code></pre>
<h3 id="_id"><a href="#_id">option: _id</a></h3>

<p>Mongoose assigns each of your schemas an <code>_id</code> field by default if one
is not passed into the <a href="/docs/api.html#schema-js">Schema</a> constructor.
The type assigned is an <a href="/docs/api.html#schema_Schema.Types">ObjectId</a>
to coincide with MongoDB&#39;s default behavior. If you don&#39;t want an <code>_id</code>
added to your schema at all, you may disable it using this option.</p>
<p>You can <strong>only</strong> use this option on subdocuments. Mongoose can&#39;t
save a document without knowing its id, so you will get an error if
you try to save a document without an <code>_id</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// default behavior</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
<span class="hljs-keyword">var</span> Page = mongoose.model(<span class="hljs-string">'Page'</span>, schema);
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Page({ name: <span class="hljs-string">'mongodb.org'</span> });
<span class="hljs-built_in">console</span>.log(p); <span class="hljs-comment">// { _id: '50341373e894ad16347efe01', name: 'mongodb.org' }</span>

<span class="hljs-comment">// disabled _id</span>
<span class="hljs-keyword">var</span> childSchema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> }, { _id: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> parentSchema = <span class="hljs-keyword">new</span> Schema({ children: [childSchema] });

<span class="hljs-keyword">var</span> Model = mongoose.model(<span class="hljs-string">'Model'</span>, parentSchema);

Model.create({ children: [{ name: <span class="hljs-string">'Luke'</span> }] }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
  <span class="hljs-comment">// doc.children[0]._id will be undefined</span>
});
</code></pre>
<h3 id="minimize"><a href="#minimize">option: minimize</a></h3>

<p>Mongoose will, by default, &quot;minimize&quot; schemas by removing empty objects.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span>, inventory: {} });
<span class="hljs-keyword">var</span> Character = mongoose.model(<span class="hljs-string">'Character'</span>, schema);

<span class="hljs-comment">// will store `inventory` field if it is not empty</span>
<span class="hljs-keyword">var</span> frodo = <span class="hljs-keyword">new</span> Character({ name: <span class="hljs-string">'Frodo'</span>, inventory: { ringOfPower: <span class="hljs-number">1</span> }});
Character.findOne({ name: <span class="hljs-string">'Frodo'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, character</span>) </span>{
  <span class="hljs-built_in">console</span>.log(character); <span class="hljs-comment">// { name: 'Frodo', inventory: { ringOfPower: 1 }}</span>
});

<span class="hljs-comment">// will not store `inventory` field if it is empty</span>
<span class="hljs-keyword">var</span> sam = <span class="hljs-keyword">new</span> Character({ name: <span class="hljs-string">'Sam'</span>, inventory: {}});
Character.findOne({ name: <span class="hljs-string">'Sam'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, character</span>) </span>{
  <span class="hljs-built_in">console</span>.log(character); <span class="hljs-comment">// { name: 'Sam' }</span>
});
</code></pre>
<p>This behavior can be overridden by setting <code>minimize</code> option to <code>false</code>. It
will then store empty objects.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span>, inventory: {} }, { minimize: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> Character = mongoose.model(<span class="hljs-string">'Character'</span>, schema);

<span class="hljs-comment">// will store `inventory` if empty</span>
<span class="hljs-keyword">var</span> sam = <span class="hljs-keyword">new</span> Character({ name: <span class="hljs-string">'Sam'</span>, inventory: {}});
Character.findOne({ name: <span class="hljs-string">'Sam'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, character</span>) </span>{
  <span class="hljs-built_in">console</span>.log(character); <span class="hljs-comment">// { name: 'Sam', inventory: {}}</span>
});
</code></pre>
<h3 id="read"><a href="#read">option: read</a></h3>

<p>Allows setting <a href="/docs/api.html#query_Query-read">query#read</a> options at the
schema level, providing us a way to apply default
<a href="http://docs.mongodb.org/manual/applications/replication/#replica-set-read-preference">ReadPreferences</a>
to all queries derived from a model.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: <span class="hljs-string">'primary'</span> });            <span class="hljs-comment">// also aliased as 'p'</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: <span class="hljs-string">'primaryPreferred'</span> });   <span class="hljs-comment">// aliased as 'pp'</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: <span class="hljs-string">'secondary'</span> });          <span class="hljs-comment">// aliased as 's'</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: <span class="hljs-string">'secondaryPreferred'</span> }); <span class="hljs-comment">// aliased as 'sp'</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: <span class="hljs-string">'nearest'</span> });            <span class="hljs-comment">// aliased as 'n'</span>
</code></pre>
<p>The alias of each pref is also permitted so instead of having to type out
&#39;secondaryPreferred&#39; and getting the spelling wrong, we can simply pass &#39;sp&#39;.</p>
<p>The read option also allows us to specify <em>tag sets</em>. These tell the
<a href="https://github.com/mongodb/node-mongodb-native/">driver</a> from which members
of the replica-set it should attempt to read. Read more about tag sets
<a href="http://docs.mongodb.org/manual/applications/replication/#tag-sets">here</a> and
<a href="http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences">here</a>.</p>
<p><em>NOTE: you may also specify the driver read pref <a href="http://mongodb.github.com/node-mongodb-native/api-generated/replset.html?highlight=strategy">strategy</a>
option when connecting:</em></p>
<pre><code class="lang-javascript"><span class="hljs-comment">// pings the replset members periodically to track network latency</span>
<span class="hljs-keyword">var</span> options = { replset: { strategy: <span class="hljs-string">'ping'</span> }};
mongoose.connect(uri, options);

<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: [<span class="hljs-string">'nearest'</span>, { disk: <span class="hljs-string">'ssd'</span> }] });
mongoose.model(<span class="hljs-string">'JellyBean'</span>, schema);
</code></pre>
<h3 id="shardKey"><a href="#shardKey">option: shardKey</a></h3>

<p>The <code>shardKey</code> option is used when we have a <a href="http://www.mongodb.org/display/DOCS/Sharding+Introduction">sharded MongoDB architecture</a>.
Each sharded collection is given a shard key which must be present in all
insert/update operations. We just need to set this schema option to the same
shard key and we’ll be all set.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({ .. }, { shardKey: { tag: <span class="hljs-number">1</span>, name: <span class="hljs-number">1</span> }})
</code></pre>
<p><em>Note that Mongoose does not send the <code>shardcollection</code> command for you. You
must configure your shards yourself.</em></p>
<h3 id="strict">option: strict</h3>

<p>The strict option, (enabled by default), ensures that values passed to our
model constructor that were not specified in our schema do not get saved to
the db.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> thingSchema = <span class="hljs-keyword">new</span> Schema({..})
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, thingSchema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing({ iAmNotInTheSchema: <span class="hljs-literal">true</span> });
thing.save(); <span class="hljs-comment">// iAmNotInTheSchema is not saved to the db</span>

<span class="hljs-comment">// set to false..</span>
<span class="hljs-keyword">var</span> thingSchema = <span class="hljs-keyword">new</span> Schema({..}, { strict: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing({ iAmNotInTheSchema: <span class="hljs-literal">true</span> });
thing.save(); <span class="hljs-comment">// iAmNotInTheSchema is now saved to the db!!</span>
</code></pre>
<p>This also affects the use of <code>doc.set()</code> to set a property value.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> thingSchema = <span class="hljs-keyword">new</span> Schema({..})
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, thingSchema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing;
thing.set(<span class="hljs-string">'iAmNotInTheSchema'</span>, <span class="hljs-literal">true</span>);
thing.save(); <span class="hljs-comment">// iAmNotInTheSchema is not saved to the db</span>
</code></pre>
<p>This value can be overridden at the model instance level by passing a second
boolean argument:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing(doc, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// enables strict mode</span>
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing(doc, <span class="hljs-literal">false</span>); <span class="hljs-comment">// disables strict mode</span>
</code></pre>
<p>The <code>strict</code> option may also be set to <code>&quot;throw&quot;</code> which will cause errors
to be produced instead of dropping the bad data.</p>
<p><em>NOTE: Any key/val set on the instance that does not exist in your schema is always ignored, regardless of schema option.</em></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> thingSchema = <span class="hljs-keyword">new</span> Schema({..})
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, thingSchema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing;
thing.iAmNotInTheSchema = <span class="hljs-literal">true</span>;
thing.save(); <span class="hljs-comment">// iAmNotInTheSchema is never saved to the db</span>
</code></pre>
<h3 id="strictQuery">option: strictQuery</h3>

<p>For backwards compatibility, the <code>strict</code> option does <strong>not</strong> apply to
the <code>filter</code> parameter for queries.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> mySchema = <span class="hljs-keyword">new</span> Schema({ field: <span class="hljs-built_in">Number</span> }, { strict: <span class="hljs-literal">true</span> });
<span class="hljs-keyword">const</span> MyModel = mongoose.model(<span class="hljs-string">'Test'</span>, mySchema);

<span class="hljs-comment">// Mongoose will **not** filter out `notInSchema: 1`, despite `strict: true`</span>
MyModel.find({ notInSchema: <span class="hljs-number">1</span> });
</code></pre>
<p>The <code>strict</code> option does apply to updates.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Mongoose will strip out `notInSchema` from the update if `strict` is</span>
<span class="hljs-comment">// not `false`</span>
MyModel.updateMany({}, { $set: { notInSchema: <span class="hljs-number">1</span> } });
</code></pre>
<p>Mongoose has a separate <code>strictQuery</code> option to toggle strict mode for
the <code>filter</code> parameter to queries.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> mySchema = <span class="hljs-keyword">new</span> Schema({ field: <span class="hljs-built_in">Number</span> }, {
  strict: <span class="hljs-literal">true</span>,
  strictQuery: <span class="hljs-literal">true</span> <span class="hljs-comment">// Turn on strict mode for query filters</span>
});
<span class="hljs-keyword">const</span> MyModel = mongoose.model(<span class="hljs-string">'Test'</span>, mySchema);

<span class="hljs-comment">// Mongoose will strip out `notInSchema: 1` because `strictQuery` is `true`</span>
MyModel.find({ notInSchema: <span class="hljs-number">1</span> });
</code></pre>
<h3 id="toJSON"><a href="#toJSON">option: toJSON</a></h3>

<p>Exactly the same as the <a href="#toObject">toObject</a> option but only applies when
the documents <code>toJSON</code> method is called.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
schema.path(<span class="hljs-string">'name'</span>).get(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
  <span class="hljs-keyword">return</span> v + <span class="hljs-string">' is my name'</span>;
});
schema.set(<span class="hljs-string">'toJSON'</span>, { getters: <span class="hljs-literal">true</span>, virtuals: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> M = mongoose.model(<span class="hljs-string">'Person'</span>, schema);
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> M({ name: <span class="hljs-string">'Max Headroom'</span> });
<span class="hljs-built_in">console</span>.log(m.toObject()); <span class="hljs-comment">// { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom' }</span>
<span class="hljs-built_in">console</span>.log(m.toJSON()); <span class="hljs-comment">// { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' }</span>
<span class="hljs-comment">// since we know toJSON is called whenever a js object is stringified:</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(m)); <span class="hljs-comment">// { "_id": "504e0cd7dd992d9be2f20b6f", "name": "Max Headroom is my name" }</span>
</code></pre>
<p>To see all available <code>toJSON/toObject</code> options, read <a href="/docs/api.html#document_Document-toObject">this</a>.</p>
<h3 id="toObject"><a href="#toObject">option: toObject</a></h3>

<p>Documents have a <a href="/docs/api.html#document_Document-toObject">toObject</a> method
which converts the mongoose document into a plain javascript object. This
method accepts a few options. Instead of applying these options on a
per-document basis we may declare the options here and have it applied to
all of this schemas documents by default.</p>
<p>To have all virtuals show up in your <code>console.log</code> output, set the
<code>toObject</code> option to <code>{ getters: true }</code>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
schema.path(<span class="hljs-string">'name'</span>).get(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
  <span class="hljs-keyword">return</span> v + <span class="hljs-string">' is my name'</span>;
});
schema.set(<span class="hljs-string">'toObject'</span>, { getters: <span class="hljs-literal">true</span> });
<span class="hljs-keyword">var</span> M = mongoose.model(<span class="hljs-string">'Person'</span>, schema);
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> M({ name: <span class="hljs-string">'Max Headroom'</span> });
<span class="hljs-built_in">console</span>.log(m); <span class="hljs-comment">// { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' }</span>
</code></pre>
<p>To see all available <code>toObject</code> options, read <a href="/docs/api.html#document_Document-toObject">this</a>.</p>
<h3 id="typeKey"><a href="#typeKey">option: typeKey</a></h3>

<p>By default, if you have an object with key &#39;type&#39; in your schema, mongoose
will interpret it as a type declaration.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Mongoose interprets this as 'loc is a String'</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ loc: { type: <span class="hljs-built_in">String</span>, coordinates: [<span class="hljs-built_in">Number</span>] } });
</code></pre>
<p>However, for applications like <a href="http://docs.mongodb.org/manual/reference/geojson/">geoJSON</a>,
the &#39;type&#39; property is important. If you want to control which key mongoose
uses to find type declarations, set the &#39;typeKey&#39; schema option.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-comment">// Mongoose interpets this as 'loc is an object with 2 keys, type and coordinates'</span>
  loc: { type: <span class="hljs-built_in">String</span>, coordinates: [<span class="hljs-built_in">Number</span>] },
  <span class="hljs-comment">// Mongoose interprets this as 'name is a String'</span>
  name: { $type: <span class="hljs-built_in">String</span> }
}, { typeKey: <span class="hljs-string">'$type'</span> }); <span class="hljs-comment">// A '$type' key means this object is a type declaration</span>
</code></pre>
<h3 id="validateBeforeSave"><a href="#validateBeforeSave">option: validateBeforeSave</a></h3>

<p>By default, documents are automatically validated before they are saved to
the database. This is to prevent saving an invalid document. If you want to
handle validation manually, and be able to save objects which don&#39;t pass
validation, you can set <code>validateBeforeSave</code> to false.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
schema.set(<span class="hljs-string">'validateBeforeSave'</span>, <span class="hljs-literal">false</span>);
schema.path(<span class="hljs-string">'name'</span>).validate(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">return</span> v != <span class="hljs-literal">null</span>;
});
<span class="hljs-keyword">var</span> M = mongoose.model(<span class="hljs-string">'Person'</span>, schema);
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> M({ name: <span class="hljs-literal">null</span> });
m.validate(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
    <span class="hljs-built_in">console</span>.log(err); <span class="hljs-comment">// Will tell you that null is not allowed.</span>
});
m.save(); <span class="hljs-comment">// Succeeds despite being invalid</span>
</code></pre>
<h3 id="versionKey"><a href="#versionKey">option: versionKey</a></h3>

<p>The <code>versionKey</code> is a property set on each document when first created by
Mongoose. This keys value contains the internal
<a href="http://aaronheckmann.tumblr.com/post/48943525537/mongoose-v3-part-1-versioning">revision</a>
of the document. The <code>versionKey</code> option is a string that represents the
path to use for versioning. The default is <code>__v</code>. If this conflicts with
your application you can configure as such:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-string">'string'</span> });
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, schema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing({ name: <span class="hljs-string">'mongoose v3'</span> });
thing.save(); <span class="hljs-comment">// { __v: 0, name: 'mongoose v3' }</span>

<span class="hljs-comment">// customized versionKey</span>
<span class="hljs-keyword">new</span> Schema({..}, { versionKey: <span class="hljs-string">'_somethingElse'</span> })
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, schema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing({ name: <span class="hljs-string">'mongoose v3'</span> });
thing.save(); <span class="hljs-comment">// { _somethingElse: 0, name: 'mongoose v3' }</span>
</code></pre>
<p>Document versioning can also be disabled by setting the <code>versionKey</code> to
<code>false</code>.
<em>DO NOT disable versioning unless you <a href="http://aaronheckmann.tumblr.com/post/48943525537/mongoose-v3-part-1-versioning">know what you are doing</a>.</em></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({..}, { versionKey: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, schema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing({ name: <span class="hljs-string">'no versioning please'</span> });
thing.save(); <span class="hljs-comment">// { name: 'no versioning please' }</span>
</code></pre>
<h3 id="collation"><a href="#collation">option: collation</a></h3>

<p>Sets a default <a href="https://docs.mongodb.com/manual/reference/collation/">collation</a>
for every query and aggregation. <a href="http://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations">Here&#39;s a beginner-friendly overview of collations</a>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({
  name: <span class="hljs-built_in">String</span>
}, { collation: { locale: <span class="hljs-string">'en_US'</span>, strength: <span class="hljs-number">1</span> } });

<span class="hljs-keyword">var</span> MyModel = db.model(<span class="hljs-string">'MyModel'</span>, schema);

MyModel.create([{ name: <span class="hljs-string">'val'</span> }, { name: <span class="hljs-string">'Val'</span> }]).
  then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> MyModel.find({ name: <span class="hljs-string">'val'</span> });
  }).
  then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">docs</span>) </span>{
    <span class="hljs-comment">// `docs` will contain both docs, because `strength: 1` means</span>
    <span class="hljs-comment">// MongoDB will ignore case when matching.</span>
  });
</code></pre>
<h3 id="skipVersioning"><a href="#skipVersioning">option: skipVersioning</a></h3>

<p><code>skipVersioning</code> allows excluding paths from versioning (i.e., the internal
revision will not be incremented even if these paths are updated). DO NOT
do this unless you know what you&#39;re doing. For subdocuments, include this
on the parent document using the fully qualified path.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({..}, { skipVersioning: { dontVersionMe: <span class="hljs-literal">true</span> } });
thing.dontVersionMe.push(<span class="hljs-string">'hey'</span>);
thing.save(); <span class="hljs-comment">// version is not incremented</span>
</code></pre>
<h3 id="timestamps"><a href="#timestamps">option: timestamps</a></h3>

<p>If set <code>timestamps</code>, mongoose assigns <code>createdAt</code> and <code>updatedAt</code> fields to
your schema, the type assigned is <a href="./api.html#schema-date-js">Date</a>.</p>
<p>By default, the name of two fields are <code>createdAt</code> and <code>updatedAt</code>, customize
the field name by setting <code>timestamps.createdAt</code> and <code>timestamps.updatedAt</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> thingSchema = <span class="hljs-keyword">new</span> Schema({..}, { timestamps: { createdAt: <span class="hljs-string">'created_at'</span> } });
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, thingSchema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing();
thing.save(); <span class="hljs-comment">// `created_at` &amp; `updatedAt` will be included</span>
</code></pre>
<h3 id="useNestedStrict"><a href="#useNestedStrict">option: useNestedStrict</a></h3>

<p>In mongoose 4, <code>update()</code> and <code>findOneAndUpdate()</code> only check the top-level
schema&#39;s strict mode setting.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> childSchema = <span class="hljs-keyword">new</span> Schema({}, { strict: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> parentSchema = <span class="hljs-keyword">new</span> Schema({ child: childSchema }, { strict: <span class="hljs-string">'throw'</span> });
<span class="hljs-keyword">var</span> Parent = mongoose.model(<span class="hljs-string">'Parent'</span>, parentSchema);
Parent.update({}, { <span class="hljs-string">'child.name'</span>: <span class="hljs-string">'Luke Skywalker'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  <span class="hljs-comment">// Error because parentSchema has `strict: throw`, even though</span>
  <span class="hljs-comment">// `childSchema` has `strict: false`</span>
});

<span class="hljs-keyword">var</span> update = { <span class="hljs-string">'child.name'</span>: <span class="hljs-string">'Luke Skywalker'</span> };
<span class="hljs-keyword">var</span> opts = { strict: <span class="hljs-literal">false</span> };
Parent.update({}, update, opts, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  <span class="hljs-comment">// This works because passing `strict: false` to `update()` overwrites</span>
  <span class="hljs-comment">// the parent schema.</span>
});
</code></pre>
<p>If you set <code>useNestedStrict</code> to true, mongoose will use the child schema&#39;s
<code>strict</code> option for casting updates.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> childSchema = <span class="hljs-keyword">new</span> Schema({}, { strict: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> parentSchema = <span class="hljs-keyword">new</span> Schema({ child: childSchema },
  { strict: <span class="hljs-string">'throw'</span>, useNestedStrict: <span class="hljs-literal">true</span> });
<span class="hljs-keyword">var</span> Parent = mongoose.model(<span class="hljs-string">'Parent'</span>, parentSchema);
Parent.update({}, { <span class="hljs-string">'child.name'</span>: <span class="hljs-string">'Luke Skywalker'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  <span class="hljs-comment">// Works!</span>
});
</code></pre>
<h3 id="plugins"><a href="#plugins">Pluggable</a></h3>

<p>Schemas are also <a href="./plugins.html">pluggable</a> which allows us to package up reusable features into
plugins that can be shared with the community or just between your projects.</p>
<h3 id="next">Next Up</h3>

<p>Now that we&#39;ve covered <code>Schemas</code>, let&#39;s take a look at <a href="/docs/schematypes.html">SchemaTypes</a>.</p>
</div></div><script type="text/javascript">!function(name,path,ctx){
  var latest,prev=name!=='Keen'&&window.Keen?window.Keen:false;ctx[name]=ctx[name]||{ready:function(fn){var h=document.getElementsByTagName('head')[0],s=document.createElement('script'),w=window,loaded;s.onload=s.onerror=s.onreadystatechange=function(){if((s.readyState&&!(/^c|loade/.test(s.readyState)))||loaded){return}s.onload=s.onreadystatechange=null;loaded=1;latest=w.Keen;if(prev){w.Keen=prev}else{try{delete w.Keen}catch(e){w.Keen=void 0}}ctx[name]=latest;ctx[name].ready(fn)};s.async=1;s.src=path;h.parentNode.insertBefore(s,h)}}
}('KeenAsync','https://d26b395fwzu5fz.cloudfront.net/keen-tracking-1.1.3.min.js',this);

KeenAsync.ready(function(){
  // Configure a client instance
  var client = new KeenAsync({
    projectId: '59aad9cbc9e77c0001ce1b32',
    writeKey: '4B38B0046086885E425D368BFAEAD8FD0D4F2DC2FA2F936FDE058D79508AEFAD9886BC020B96520823BB9C8241D9D9BCFDC0EF52E6033BD89D06E4B24FC13AE955896BF443406269A84DD009CEB5862DCEC944874DB2107FD648DA91ADC1E6DE'
  });

  client.recordEvent('pageView', {
    host: window.location.host,
    pathname: window.location.pathname,
    hash: window.location.hash
  });
});</script><script type="text/javascript">(function (window, document) {
  var layout   = document.getElementById('layout'),
      menu     = document.getElementById('menu'),
      menuLink = document.getElementById('menuLink'),
      content  = document.getElementById('content');

  function toggleClass(element, className) {
      var classes = element.className.split(/\s+/),
          length = classes.length,
          i = 0;

      for(; i < length; i++) {
        if (classes[i] === className) {
          classes.splice(i, 1);
          break;
        }
      }
      // The className is not found
      if (length === classes.length) {
          classes.push(className);
      }

      element.className = classes.join(' ');
  }

  function toggleAll(e) {
      var active = 'active';

      e.preventDefault();
      toggleClass(layout, active);
      toggleClass(menu, active);
      toggleClass(menuLink, active);
  }

  menuLink.onclick = function (e) {
      toggleAll(e);
  };

  content.onclick = function(e) {
      if (menu.className.indexOf('active') !== -1) {
          toggleAll(e);
      }
  };

}(this, this.document));</script></div></body></html>