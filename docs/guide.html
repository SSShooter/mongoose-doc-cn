<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Mongoose v5.0.15 中文文档： Schemas</title><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"><link rel="stylesheet" href="/docs/css/github.css"><link rel="stylesheet" href="/docs/css/mongoose5.css"><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="manifest" href="images/favicon/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="images/favicon/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"></head><body><div id="layout"><div id="mobile-menu"><a id="menuLink" href="#menu" class="menu-link"><span></span></a><div id="mobile-logo-container"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div></div><div id="menu"><div class="pure-menu"><div id="logo-container" class="pure-menu-heading"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div><ul class="pure-menu-list"><li class="pure-menu-item"><a href="/docs/index.html" class="pure-menu-link">快速开始</a></li><li class="pure-menu-item"><a href="/docs/guide.html" class="pure-menu-link">Schemas</a></li><li class="pure-menu-item sub-item"><a href="/docs/schematypes.html" class="pure-menu-link">SchemaTypes</a></li><li class="pure-menu-item sub-item"><a href="/docs/connections.html" class="pure-menu-link">Connections</a></li><li class="pure-menu-item sub-item"><a href="/docs/models.html" class="pure-menu-link">Models</a></li><li class="pure-menu-item sub-item"><a href="/docs/documents.html" class="pure-menu-link">Documents</a></li><li class="pure-menu-item sub-item"><a href="/docs/subdocs.html" class="pure-menu-link">Subdocuments</a></li><li class="pure-menu-item sub-item"><a href="/docs/queries.html" class="pure-menu-link">Queries</a></li><li class="pure-menu-item sub-item"><a href="/docs/validation.html" class="pure-menu-link">验证</a></li><li class="pure-menu-item sub-item"><a href="/docs/middleware.html" class="pure-menu-link">中间件</a></li><li class="pure-menu-item sub-item"><a href="/docs/populate.html" class="pure-menu-link">Populate</a></li><li class="pure-menu-item sub-item"><a href="/docs/discriminators.html" class="pure-menu-link">Discriminators</a></li><li class="pure-menu-item sub-item"><a href="/docs/plugins.html" class="pure-menu-link">插件</a></li><li class="pure-menu-item sub-item"><a href="/docs/lambda.html" class="pure-menu-link">AWS Lambda</a></li><li class="pure-menu-item"><a href="/docs/api.html" class="pure-menu-link">API 文档</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Schema" class="pure-menu-link">Schema</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Connection" class="pure-menu-link">Connection</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Document" class="pure-menu-link">Document</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Model" class="pure-menu-link">Model</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Query" class="pure-menu-link">Query</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Aggregate" class="pure-menu-link">Aggregate</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Schematype" class="pure-menu-link">SchemaType</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Virtualtype" class="pure-menu-link">VirtualType</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Error" class="pure-menu-link">Error</a></li><li class="pure-menu-item"><a href="/docs/compatibility.html" class="pure-menu-link">Version Compatibility</a></li><li class="pure-menu-item"><a href="/docs/faq.html" class="pure-menu-link">FAQ</a></li><li class="carbon-ad"><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=mongoosejscom" id="_carbonads_js"></script></li></ul></div></div><div class="container"><div id="content"><h2>Schemas</h2><div class="important"><p>建议先阅读<a href="./index.html">快速上手</a>，简单了解一下Mongoose的工作流程。
如果你要从4.x迁移到5.x，请阅读<a href="https://github.com/Automattic/mongoose/blob/master/migrating_to_5.md">迁移指引</a>.</p>
</div><h3 id="definition"><a href="#definition">定义一个schema</a></h3>

<p>Mongoose 的一切始于 Schema。每个 schema 都会映射到一个 MongoDB
collection ，并定义这个collection里的文档的构成。</p>
<pre><code class="lang-javascript">  <span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
  <span class="hljs-keyword">var</span> Schema = mongoose.Schema;

  <span class="hljs-keyword">var</span> blogSchema = <span class="hljs-keyword">new</span> Schema({
    title:  <span class="hljs-built_in">String</span>,
    author: <span class="hljs-built_in">String</span>,
    body:   <span class="hljs-built_in">String</span>,
    comments: [{ body: <span class="hljs-built_in">String</span>, date: <span class="hljs-built_in">Date</span> }],
    date: { type: <span class="hljs-built_in">Date</span>, <span class="hljs-keyword">default</span>: <span class="hljs-built_in">Date</span>.now },
    hidden: <span class="hljs-built_in">Boolean</span>,
    meta: {
      votes: <span class="hljs-built_in">Number</span>,
      favs:  <span class="hljs-built_in">Number</span>
    }
  });
</code></pre>
<p>在这之后你还想添加 keys 的话， 请使用
<a href="./api.html#schema_Schema-add">Schema#add</a> 方法。</p>
<p>document 里每个属性的类型都会被转换为 在 <code>blogSchema</code> 里定义对应的 <a href="./api.html#schematype_SchemaType">SchemaType</a>。
例如 <code>title</code> 属性会被转换为 SchemaType <a href="./api.html#schema-string-js">String</a>，
而 <code>date</code>属性会被转换为 SchemaType <code>Date</code>。
还可以像上面 <code>meta</code> 属性，更详细地指定嵌套在里面的属性类型。</p>
<p>允许使用的 SchemaTypes 有:</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Date</li>
<li>Buffer</li>
<li>Boolean</li>
<li>Mixed</li>
<li>ObjectId</li>
<li>Array</li>
</ul>
<p>更多关于 <a href="./schematypes.html">SchemaTypes</a></p>
<p>Schema的功能不只是定义文档结构和属性类型，它可以定义——</p>
<ul>
<li>document 的 <a href="#methods">instance methods</a></li>
<li>model 的 <a href="#statics">static Model methods</a></li>
<li><a href="#indexes">复合索引</a></li>
<li>文档的生命周期钩子，也成为<a href="./middleware.html">中间件</a></li>
</ul>
<h3 id="models"><a href="#models">创建一个 model</a></h3>

<p>我们要把 schema 转换为一个 <a href="./models.html">Model</a>，
使用 <code>mongoose.model(modelName, schema)</code> 函数：</p>
<pre><code class="lang-javascript">  <span class="hljs-keyword">var</span> Blog = mongoose.model(<span class="hljs-string">'Blog'</span>, blogSchema);
  <span class="hljs-comment">// ready to go!</span>
</code></pre>
<h3 id="methods"><a href="#methods">实例方法（method）</a></h3>

<p><a href="./documents.html">documents</a> 是 <code>Models</code> 的实例。 Document 有很多自带的<a href="./api.html#document-js">实例方法</a>，
当然也可以自定义我们自己的方法。</p>
<pre><code class="lang-javascript">  <span class="hljs-comment">// define a schema</span>
  <span class="hljs-keyword">var</span> animalSchema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span>, type: <span class="hljs-built_in">String</span> });

  <span class="hljs-comment">// assign a function to the "methods" object of our animalSchema</span>
  animalSchema.methods.findSimilarTypes = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.model(<span class="hljs-string">'Animal'</span>).find({ type: <span class="hljs-keyword">this</span>.type }, cb);
  };
</code></pre>
<p>现在所有 <code>animal</code> 实例都有 <code>findSimilarTypes</code> 方法：</p>
<pre><code class="lang-javascript">  <span class="hljs-keyword">var</span> Animal = mongoose.model(<span class="hljs-string">'Animal'</span>, animalSchema);
  <span class="hljs-keyword">var</span> dog = <span class="hljs-keyword">new</span> Animal({ type: <span class="hljs-string">'dog'</span> });

  dog.findSimilarTypes(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, dogs</span>) </span>{
    <span class="hljs-built_in">console</span>.log(dogs); <span class="hljs-comment">// woof</span>
  });
</code></pre>
<ul>
<li>重写 mongoose 的默认方法会造成无法预料的结果，<a href="./api.html#schema_Schema.reserved">相关链接</a>。 </li>
<li><strong>不要</strong>在自定义方法中使用 ES6 箭头函数，会造成 this 指向错误。</li>
</ul>
<h3 id="statics"><a href="#statics">静态方法（static）</a></h3>

<p>添加 <code>Model</code> 的静态方法也十分简单，继续用 <code>animalSchema</code> 举例：</p>
<pre><code class="lang-javascript">  <span class="hljs-comment">// assign a function to the "statics" object of our animalSchema</span>
  animalSchema.statics.findByName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, cb</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.find({ name: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(name, <span class="hljs-string">'i'</span>) }, cb);
  };

  <span class="hljs-keyword">var</span> Animal = mongoose.model(<span class="hljs-string">'Animal'</span>, animalSchema);
  Animal.findByName(<span class="hljs-string">'fido'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, animals</span>) </span>{
    <span class="hljs-built_in">console</span>.log(animals);
  });
</code></pre>
<p>同样<strong>不要</strong>在静态方法中使用 ES6 箭头函数</p>
<h3 id="query-helpers"><a href="#query-helpers">查询助手（query helper）</a></h3>

<p>查询助手作用于 query 实例，方便你自定义拓展你的 <a href="./queries.html">链式查询</a></p>
<pre><code class="lang-javascript">  animalSchema.query.byName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.find({ name: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(name, <span class="hljs-string">'i'</span>) });
  };

  <span class="hljs-keyword">var</span> Animal = mongoose.model(<span class="hljs-string">'Animal'</span>, animalSchema);
  Animal.find().byName(<span class="hljs-string">'fido'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, animals</span>) </span>{
    <span class="hljs-built_in">console</span>.log(animals);
  });
</code></pre>
<h3 id="indexes"><a href="#indexes">索引（index）</a></h3>

<p>MongoDB 支持 <a href="http://docs.mongodb.org/manual/indexes/">secondary indexes</a>.
在 mongoose 中，我们在 <code>Schema</code> 中定义索引。索引分字段级别和schema级别，
<a href="https://docs.mongodb.com/manual/core/index-compound/">复合索引</a> 需要在 schema 级别定义。</p>
<pre><code class="lang-javascript">  <span class="hljs-keyword">var</span> animalSchema = <span class="hljs-keyword">new</span> Schema({
    name: <span class="hljs-built_in">String</span>,
    type: <span class="hljs-built_in">String</span>,
    tags: { type: [<span class="hljs-built_in">String</span>], index: <span class="hljs-literal">true</span> } <span class="hljs-comment">// field level</span>
  });

  animalSchema.index({ name: <span class="hljs-number">1</span>, type: <span class="hljs-number">-1</span> }); <span class="hljs-comment">// schema level</span>
</code></pre>
<p>应用启动时， Mongoose 会自动调用 <a href="https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#db.collection.createIndex"><code>createIndex</code></a> 初始化你定义的索引。
Mongoose 顺序处理每一个 <code>createIndex</code> ，然后在model触发 &#39;index&#39; 事件。
While nice for development, it is recommended this behavior be disabled 
in production since index creation can cause a <a href="http://docs.mongodb.org/manual/core/indexes/#index-creation-operations">significant performance impact</a>. 
Disable the behavior by setting the <code>autoIndex</code> option of your schema to <code>false</code>, or globally on the connection by setting the option <code>autoIndex</code> to <code>false</code>.</p>
<pre><code class="lang-javascript">  mongoose.connect(<span class="hljs-string">'mongodb://user:pass@localhost:port/database'</span>, { autoIndex: <span class="hljs-literal">false</span> });
  <span class="hljs-comment">// or</span>
  mongoose.createConnection(<span class="hljs-string">'mongodb://user:pass@localhost:port/database'</span>, { autoIndex: <span class="hljs-literal">false</span> });
  <span class="hljs-comment">// or</span>
  animalSchema.set(<span class="hljs-string">'autoIndex'</span>, <span class="hljs-literal">false</span>);
  <span class="hljs-comment">// or</span>
  <span class="hljs-keyword">new</span> Schema({..}, { autoIndex: <span class="hljs-literal">false</span> });
</code></pre>
<p>索引构建完成或失败后，Mongoose 会触发 <code>index</code> 事件。</p>
<pre><code class="lang-javascript">  <span class="hljs-comment">// Will cause an error because mongodb has an _id index by default that</span>
  <span class="hljs-comment">// is not sparse</span>
  animalSchema.index({ _id: <span class="hljs-number">1</span> }, { sparse: <span class="hljs-literal">true</span> });
  <span class="hljs-keyword">var</span> Animal = mongoose.model(<span class="hljs-string">'Animal'</span>, animalSchema);

  Animal.on(<span class="hljs-string">'index'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
    <span class="hljs-comment">// "_id index cannot be sparse"</span>
    <span class="hljs-built_in">console</span>.log(error.message);
  });
</code></pre>
<p>相关链接 <a href="./api.html#model_Model.ensureIndexes">Model#ensureIndexes</a> </p>
<h3 id="virtuals"><a href="#virtuals">虚拟值（Virtual）</a></h3>

<p><a href="./api.html#schema_Schema-virtual">Virtuals</a> 是 document 的属性，但是不会被保存到 MongoDB。
getter 可以用于格式化和组合字段数据，
setter 可以很方便地分解一个值到多个字段。</p>
<pre><code class="lang-javascript">  <span class="hljs-comment">// define a schema</span>
  <span class="hljs-keyword">var</span> personSchema = <span class="hljs-keyword">new</span> Schema({
    name: {
      first: <span class="hljs-built_in">String</span>,
      last: <span class="hljs-built_in">String</span>
    }
  });

  <span class="hljs-comment">// compile our model</span>
  <span class="hljs-keyword">var</span> Person = mongoose.model(<span class="hljs-string">'Person'</span>, personSchema);

  <span class="hljs-comment">// create a document</span>
  <span class="hljs-keyword">var</span> axl = <span class="hljs-keyword">new</span> Person({
    name: { first: <span class="hljs-string">'Axl'</span>, last: <span class="hljs-string">'Rose'</span> }
  });
</code></pre>
<p>如果你要log出全名，可以这么做：</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">console</span>.log(axl.name.first + <span class="hljs-string">' '</span> + axl.name.last); <span class="hljs-comment">// Axl Rose</span>
</code></pre>
<p>但是每次都这么拼接实在太麻烦了，
推荐你使用<a href="./api.html#virtualtype_VirtualType-get">virtual property getter</a>，
这个方法允许你定义一个 <code>fullName</code> 属性，但不必保存到数据库。</p>
<pre><code class="lang-javascript">personSchema.virtual(<span class="hljs-string">'fullName'</span>).get(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.first + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.name.last;
});
</code></pre>
<p>现在, mongoose 可以调用 getter 函数访问
<code>fullName</code> 属性：</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">console</span>.log(axl.fullName); <span class="hljs-comment">// Axl Rose</span>
</code></pre>
<p>如果对 document 使用 <code>toJSON()</code> 或 <code>toObject()</code>，默认不包括虚拟值，
你需要额外向 <a href="./api.html#document_Document-toObject">toObject()</a> 或者 <code>toJSON()</code>
传入参数 <code>{ virtuals: true }</code>。</p>
<p>你也可以设定虚拟值的 setter ，下例中，当你赋值到虚拟值时，它可以自动拆分到其他属性：</p>
<pre><code class="lang-javascript">personSchema.virtual(<span class="hljs-string">'fullName'</span>).
  get(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.first + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.name.last; }).
  set(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
    <span class="hljs-keyword">this</span>.name.first = v.substr(<span class="hljs-number">0</span>, v.indexOf(<span class="hljs-string">' '</span>));
    <span class="hljs-keyword">this</span>.name.last = v.substr(v.indexOf(<span class="hljs-string">' '</span>) + <span class="hljs-number">1</span>);
  });

axl.fullName = <span class="hljs-string">'William Rose'</span>; <span class="hljs-comment">// Now `axl.name.first` is "William"</span>
</code></pre>
<p>再次强调，虚拟值不能用于查询和字段选择，因为虚拟值不储存于 MongoDB。</p>
<h5 id="aliases"><a href="#aliases">别名（Alias）</a></h5>

<p>Aliase 是一种特殊的虚拟值，它的 getter 和 setter
会无缝链接到另一个值。这是一个节省带宽的做法，
你可以储存一个更短的属性名到数据库，同时在调用的时候保持可读性。 </p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> personSchema = <span class="hljs-keyword">new</span> Schema({
  n: {
    type: <span class="hljs-built_in">String</span>,
    <span class="hljs-comment">// Now accessing `name` will get you the value of `n`, and setting `n` will set the value of `name`</span>
    alias: <span class="hljs-string">'name'</span>
  }
});

<span class="hljs-comment">// Setting `name` will propagate to `n`</span>
<span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person({ name: <span class="hljs-string">'Val'</span> });
<span class="hljs-built_in">console</span>.log(person); <span class="hljs-comment">// { n: 'Val' }</span>
<span class="hljs-built_in">console</span>.log(person.toObject({ virtuals: <span class="hljs-literal">true</span> })); <span class="hljs-comment">// { n: 'Val', name: 'Val' }</span>
<span class="hljs-built_in">console</span>.log(person.name); <span class="hljs-comment">// "Val"</span>

person.name = <span class="hljs-string">'Not Val'</span>;
<span class="hljs-built_in">console</span>.log(person); <span class="hljs-comment">// { n: 'Not Val' }</span>
</code></pre>
<h3 id="options"><a href="#options">选项</a></h3>

<p>Schemas 有很多可配置选项，你可以在构造时传入或者直接 <code>set</code>：</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({..}, options);

<span class="hljs-comment">// or</span>

<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..});
schema.set(option, value);
</code></pre>
<p>Valid options:</p>
<ul>
<li><a href="#autoIndex">autoIndex</a></li>
<li><a href="#bufferCommands">bufferCommands</a></li>
<li><a href="#capped">capped</a></li>
<li><a href="#collection">collection</a></li>
<li><a href="#id">id</a></li>
<li><a href="#_id">_id</a></li>
<li><a href="#minimize">minimize</a></li>
<li><a href="#read">read</a></li>
<li><a href="#shardKey">shardKey</a></li>
<li><a href="#strict">strict</a></li>
<li><a href="#strictQuery">strictQuery</a></li>
<li><a href="#toJSON">toJSON</a></li>
<li><a href="#toObject">toObject</a></li>
<li><a href="#typeKey">typeKey</a></li>
<li><a href="#validateBeforeSave">validateBeforeSave</a></li>
<li><a href="#versionKey">versionKey</a></li>
<li><a href="#collation">collation</a></li>
<li><a href="#skipVersioning">skipVersioning</a></li>
<li><a href="#timestamps">timestamps</a></li>
<li><a href="#useNestedStrict">useNestedStrict</a></li>
</ul>
<h3 id="autoIndex"><a href="#autoIndex">option: autoIndex</a></h3>

<p>应用启动时，Mongoose 自动发送
<a href="https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#db.collection.createIndex"><code>createIndex</code></a> 指令，
schema 里的每个 index 都会被创建。
如果你需要关闭自动创建功能或者需要在创建后进行一系列操作，
可以把 <code>autoIndex</code> 设为 <code>false</code>，
然后对 model 调用 <a href="./api.html#model_Model.ensureIndexes">ensureIndexes</a>：</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { autoIndex: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> Clock = mongoose.model(<span class="hljs-string">'Clock'</span>, schema);
Clock.ensureIndexes(callback);
</code></pre>
<h3 id="bufferCommands"><a href="#bufferCommands">option: bufferCommands</a></h3>

<p>By default, mongoose buffers commands when the connection goes down until
the driver manages to reconnect. To disable buffering, set <code>bufferCommands</code>
to false.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { bufferCommands: <span class="hljs-literal">false</span> });
</code></pre>
<p>The schema <code>bufferCommands</code> option overrides the global <code>bufferCommands</code> option.</p>
<pre><code class="lang-javascript">mongoose.set(<span class="hljs-string">'bufferCommands'</span>, <span class="hljs-literal">true</span>);
<span class="hljs-comment">// Schema option below overrides the above, if the schema option is set.</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { bufferCommands: <span class="hljs-literal">false</span> });
</code></pre>
<h3 id="capped"><a href="#capped">option: capped</a></h3>

<p>Mongoose 支持 MongoDB 的 <a href="http://www.mongodb.org/display/DOCS/Capped+Collections">capped</a>
collections。 要从底层把 collection 设定为 <code>capped</code> （封顶）, 
可以把 collection 的最大容量设定到 <code>capped</code> 选项（单位<a href="http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-size.">bytes</a>）。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({..}, { capped: <span class="hljs-number">1024</span> });
</code></pre>
<p>The <code>capped</code> option may also be set to an object if you want to pass
additional options like <a href="http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-max">max</a>
or <a href="http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-autoIndexId">autoIndexId</a>.
这个情况下你需要显式传入必要值 <code>size</code>。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({..}, { capped: { size: <span class="hljs-number">1024</span>, max: <span class="hljs-number">1000</span>, autoIndexId: <span class="hljs-literal">true</span> } });
</code></pre>
<h3 id="collection"><a href="#collection">option: collection</a></h3>

<p>Mongoose 通过 <a href="./api.html#utils_exports.toCollectionName">utils.toCollectionName</a> 方法
默认生成 collection 的名称（生成 model 名称的复数形式）。
设置这个选项可以自定义名称。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> dataSchema = <span class="hljs-keyword">new</span> Schema({..}, { collection: <span class="hljs-string">'data'</span> });
</code></pre>
<h3 id="id"><a href="#id">option: id</a></h3>

<p>Mongoose 会默认生成一个虚拟值 <code>id</code>，指向文档的 <code>_id</code> 字段。
如果你不需要 <code>id</code> 虚拟值，可以通过这个选项禁用此功能。</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// default behavior</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
<span class="hljs-keyword">var</span> Page = mongoose.model(<span class="hljs-string">'Page'</span>, schema);
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Page({ name: <span class="hljs-string">'mongodb.org'</span> });
<span class="hljs-built_in">console</span>.log(p.id); <span class="hljs-comment">// '50341373e894ad16347efe01'</span>

<span class="hljs-comment">// disabled id</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> }, { id: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> Page = mongoose.model(<span class="hljs-string">'Page'</span>, schema);
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Page({ name: <span class="hljs-string">'mongodb.org'</span> });
<span class="hljs-built_in">console</span>.log(p.id); <span class="hljs-comment">// undefined</span>
</code></pre>
<h3 id="_id"><a href="#_id">option: _id</a></h3>

<p>Mongoose 默认给你的 <a href="/docs/api.html#schema-js">Schema</a> 赋值一个 <code>_id</code>。
这个值的类型是 <a href="/docs/api.html#schema_Schema.Types">ObjectId</a>，这与MongoDB的默认表现一致。
如果你不需要 <code>_id</code>，可以通过这个选项禁用此功能。</p>
<p>此选项<strong>只能</strong>用于 subdocument。
Mongoose 不能保存没有id的文档，如果你硬是要这么做，会报错的哦。</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// default behavior</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
<span class="hljs-keyword">var</span> Page = mongoose.model(<span class="hljs-string">'Page'</span>, schema);
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Page({ name: <span class="hljs-string">'mongodb.org'</span> });
<span class="hljs-built_in">console</span>.log(p); <span class="hljs-comment">// { _id: '50341373e894ad16347efe01', name: 'mongodb.org' }</span>

<span class="hljs-comment">// disabled _id</span>
<span class="hljs-keyword">var</span> childSchema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> }, { _id: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> parentSchema = <span class="hljs-keyword">new</span> Schema({ children: [childSchema] });

<span class="hljs-keyword">var</span> Model = mongoose.model(<span class="hljs-string">'Model'</span>, parentSchema);

Model.create({ children: [{ name: <span class="hljs-string">'Luke'</span> }] }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
  <span class="hljs-comment">// doc.children[0]._id will be undefined</span>
});
</code></pre>
<h3 id="minimize"><a href="#minimize">option: minimize</a></h3>

<p>Mongoose 默认不保存空对象。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span>, inventory: {} });
<span class="hljs-keyword">var</span> Character = mongoose.model(<span class="hljs-string">'Character'</span>, schema);

<span class="hljs-comment">// will store `inventory` field if it is not empty</span>
<span class="hljs-keyword">var</span> frodo = <span class="hljs-keyword">new</span> Character({ name: <span class="hljs-string">'Frodo'</span>, inventory: { ringOfPower: <span class="hljs-number">1</span> }});
Character.findOne({ name: <span class="hljs-string">'Frodo'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, character</span>) </span>{
  <span class="hljs-built_in">console</span>.log(character); <span class="hljs-comment">// { name: 'Frodo', inventory: { ringOfPower: 1 }}</span>
});

<span class="hljs-comment">// will not store `inventory` field if it is empty</span>
<span class="hljs-keyword">var</span> sam = <span class="hljs-keyword">new</span> Character({ name: <span class="hljs-string">'Sam'</span>, inventory: {}});
Character.findOne({ name: <span class="hljs-string">'Sam'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, character</span>) </span>{
  <span class="hljs-built_in">console</span>.log(character); <span class="hljs-comment">// { name: 'Sam' }</span>
});
</code></pre>
<p>如果把 <code>minimize</code> 选项设为 <code>false</code>，Mongoose 将保存空对象。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span>, inventory: {} }, { minimize: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> Character = mongoose.model(<span class="hljs-string">'Character'</span>, schema);

<span class="hljs-comment">// will store `inventory` if empty</span>
<span class="hljs-keyword">var</span> sam = <span class="hljs-keyword">new</span> Character({ name: <span class="hljs-string">'Sam'</span>, inventory: {}});
Character.findOne({ name: <span class="hljs-string">'Sam'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, character</span>) </span>{
  <span class="hljs-built_in">console</span>.log(character); <span class="hljs-comment">// { name: 'Sam', inventory: {}}</span>
});
</code></pre>
<h3 id="read"><a href="#read">option: read</a></h3>

<p>Allows setting <a href="/docs/api.html#query_Query-read">query#read</a> options at the
schema level, providing us a way to apply default
<a href="http://docs.mongodb.org/manual/applications/replication/#replica-set-read-preference">ReadPreferences</a>
to all queries derived from a model.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: <span class="hljs-string">'primary'</span> });            <span class="hljs-comment">// also aliased as 'p'</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: <span class="hljs-string">'primaryPreferred'</span> });   <span class="hljs-comment">// aliased as 'pp'</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: <span class="hljs-string">'secondary'</span> });          <span class="hljs-comment">// aliased as 's'</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: <span class="hljs-string">'secondaryPreferred'</span> }); <span class="hljs-comment">// aliased as 'sp'</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: <span class="hljs-string">'nearest'</span> });            <span class="hljs-comment">// aliased as 'n'</span>
</code></pre>
<p>The alias of each pref is also permitted so instead of having to type out
&#39;secondaryPreferred&#39; and getting the spelling wrong, we can simply pass &#39;sp&#39;.</p>
<p>The read option also allows us to specify <em>tag sets</em>. These tell the
<a href="https://github.com/mongodb/node-mongodb-native/">driver</a> from which members
of the replica-set it should attempt to read. Read more about tag sets
<a href="http://docs.mongodb.org/manual/applications/replication/#tag-sets">here</a> and
<a href="http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences">here</a>.</p>
<p><em>NOTE: you may also specify the driver read pref <a href="http://mongodb.github.com/node-mongodb-native/api-generated/replset.html?highlight=strategy">strategy</a>
option when connecting:</em></p>
<pre><code class="lang-javascript"><span class="hljs-comment">// pings the replset members periodically to track network latency</span>
<span class="hljs-keyword">var</span> options = { replset: { strategy: <span class="hljs-string">'ping'</span> }};
mongoose.connect(uri, options);

<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({..}, { read: [<span class="hljs-string">'nearest'</span>, { disk: <span class="hljs-string">'ssd'</span> }] });
mongoose.model(<span class="hljs-string">'JellyBean'</span>, schema);
</code></pre>
<h3 id="shardKey"><a href="#shardKey">option: shardKey</a></h3>

<p>分片相关
The <code>shardKey</code> option is used when we have a <a href="http://www.mongodb.org/display/DOCS/Sharding+Introduction">sharded MongoDB architecture</a>.
Each sharded collection is given a shard key which must be present in all
insert/update operations. We just need to set this schema option to the same
shard key and we’ll be all set.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({ .. }, { shardKey: { tag: <span class="hljs-number">1</span>, name: <span class="hljs-number">1</span> }})
</code></pre>
<p><em>Note that Mongoose does not send the <code>shardcollection</code> command for you. You
must configure your shards yourself.</em></p>
<h3 id="strict">option: strict</h3>

<p>Strict 选项默认为 true，这意味着你不能 <code>save</code> schema 里没有声明的属性。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> thingSchema = <span class="hljs-keyword">new</span> Schema({..})
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, thingSchema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing({ iAmNotInTheSchema: <span class="hljs-literal">true</span> });
thing.save(); <span class="hljs-comment">// iAmNotInTheSchema is not saved to the db</span>

<span class="hljs-comment">// set to false..</span>
<span class="hljs-keyword">var</span> thingSchema = <span class="hljs-keyword">new</span> Schema({..}, { strict: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing({ iAmNotInTheSchema: <span class="hljs-literal">true</span> });
thing.save(); <span class="hljs-comment">// iAmNotInTheSchema is now saved to the db!!</span>
</code></pre>
<p><code>doc.set()</code> 也受该选项影响：</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> thingSchema = <span class="hljs-keyword">new</span> Schema({..})
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, thingSchema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing;
thing.set(<span class="hljs-string">'iAmNotInTheSchema'</span>, <span class="hljs-literal">true</span>);
thing.save(); <span class="hljs-comment">// iAmNotInTheSchema is not saved to the db</span>
</code></pre>
<p>这个值可以在 model 级别重写，在第二个参数值传入：</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing(doc, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// enables strict mode</span>
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing(doc, <span class="hljs-literal">false</span>); <span class="hljs-comment">// disables strict mode</span>
</code></pre>
<p>The <code>strict</code> option may also be set to <code>&quot;throw&quot;</code> which will cause errors
to be produced instead of dropping the bad data.</p>
<p><em>NOTE: Any key/val set on the instance that does not exist in your schema is always ignored, regardless of schema option.</em></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> thingSchema = <span class="hljs-keyword">new</span> Schema({..})
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, thingSchema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing;
thing.iAmNotInTheSchema = <span class="hljs-literal">true</span>;
thing.save(); <span class="hljs-comment">// iAmNotInTheSchema is never saved to the db</span>
</code></pre>
<h3 id="strictQuery">option: strictQuery</h3>

<p>For backwards compatibility, the <code>strict</code> option does <strong>not</strong> apply to
the <code>filter</code> parameter for queries.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> mySchema = <span class="hljs-keyword">new</span> Schema({ field: <span class="hljs-built_in">Number</span> }, { strict: <span class="hljs-literal">true</span> });
<span class="hljs-keyword">const</span> MyModel = mongoose.model(<span class="hljs-string">'Test'</span>, mySchema);

<span class="hljs-comment">// Mongoose will **not** filter out `notInSchema: 1`, despite `strict: true`</span>
MyModel.find({ notInSchema: <span class="hljs-number">1</span> });
</code></pre>
<p>The <code>strict</code> option does apply to updates.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Mongoose will strip out `notInSchema` from the update if `strict` is</span>
<span class="hljs-comment">// not `false`</span>
MyModel.updateMany({}, { $set: { notInSchema: <span class="hljs-number">1</span> } });
</code></pre>
<p>Mongoose has a separate <code>strictQuery</code> option to toggle strict mode for
the <code>filter</code> parameter to queries.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> mySchema = <span class="hljs-keyword">new</span> Schema({ field: <span class="hljs-built_in">Number</span> }, {
  strict: <span class="hljs-literal">true</span>,
  strictQuery: <span class="hljs-literal">true</span> <span class="hljs-comment">// Turn on strict mode for query filters</span>
});
<span class="hljs-keyword">const</span> MyModel = mongoose.model(<span class="hljs-string">'Test'</span>, mySchema);

<span class="hljs-comment">// Mongoose will strip out `notInSchema: 1` because `strictQuery` is `true`</span>
MyModel.find({ notInSchema: <span class="hljs-number">1</span> });
</code></pre>
<h3 id="toJSON"><a href="#toJSON">option: toJSON</a></h3>

<p>Exactly the same as the <a href="#toObject">toObject</a> option but only applies when
the documents <code>toJSON</code> method is called.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
schema.path(<span class="hljs-string">'name'</span>).get(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
  <span class="hljs-keyword">return</span> v + <span class="hljs-string">' is my name'</span>;
});
schema.set(<span class="hljs-string">'toJSON'</span>, { getters: <span class="hljs-literal">true</span>, virtuals: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> M = mongoose.model(<span class="hljs-string">'Person'</span>, schema);
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> M({ name: <span class="hljs-string">'Max Headroom'</span> });
<span class="hljs-built_in">console</span>.log(m.toObject()); <span class="hljs-comment">// { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom' }</span>
<span class="hljs-built_in">console</span>.log(m.toJSON()); <span class="hljs-comment">// { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' }</span>
<span class="hljs-comment">// since we know toJSON is called whenever a js object is stringified:</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(m)); <span class="hljs-comment">// { "_id": "504e0cd7dd992d9be2f20b6f", "name": "Max Headroom is my name" }</span>
</code></pre>
<p>To see all available <code>toJSON/toObject</code> options, read <a href="/docs/api.html#document_Document-toObject">this</a>.</p>
<h3 id="toObject"><a href="#toObject">option: toObject</a></h3>

<p>Documents 的 <a href="/docs/api.html#document_Document-toObject">toObject</a> 方法可以把文档转换成一个 
plain javascript object （也就是去掉里面的方法）。
这是一个可以接收多个参数的方法，我们可以在 schemas 定义这些参数。</p>
<p>例如要打印出虚拟值，可以向 <code>toObject</code> 传入 <code>{ getters: true }</code>：</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
schema.path(<span class="hljs-string">'name'</span>).get(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
  <span class="hljs-keyword">return</span> v + <span class="hljs-string">' is my name'</span>;
});
schema.set(<span class="hljs-string">'toObject'</span>, { getters: <span class="hljs-literal">true</span> });
<span class="hljs-keyword">var</span> M = mongoose.model(<span class="hljs-string">'Person'</span>, schema);
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> M({ name: <span class="hljs-string">'Max Headroom'</span> });
<span class="hljs-built_in">console</span>.log(m); <span class="hljs-comment">// { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' }</span>
</code></pre>
<p>完整的 <code>toObject</code> 选项请看<a href="/docs/api.html#document_Document-toObject">这里</a>。</p>
<h3 id="typeKey"><a href="#typeKey">option: typeKey</a></h3>

<p>By default, if you have an object with key &#39;type&#39; in your schema, mongoose
will interpret it as a type declaration.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Mongoose interprets this as 'loc is a String'</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ loc: { type: <span class="hljs-built_in">String</span>, coordinates: [<span class="hljs-built_in">Number</span>] } });
</code></pre>
<p>However, for applications like <a href="http://docs.mongodb.org/manual/reference/geojson/">geoJSON</a>,
the &#39;type&#39; property is important. If you want to control which key mongoose
uses to find type declarations, set the &#39;typeKey&#39; schema option.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-comment">// Mongoose interpets this as 'loc is an object with 2 keys, type and coordinates'</span>
  loc: { type: <span class="hljs-built_in">String</span>, coordinates: [<span class="hljs-built_in">Number</span>] },
  <span class="hljs-comment">// Mongoose interprets this as 'name is a String'</span>
  name: { $type: <span class="hljs-built_in">String</span> }
}, { typeKey: <span class="hljs-string">'$type'</span> }); <span class="hljs-comment">// A '$type' key means this object is a type declaration</span>
</code></pre>
<h3 id="validateBeforeSave"><a href="#validateBeforeSave">option: validateBeforeSave</a></h3>

<p>By default, documents are automatically validated before they are saved to
the database. This is to prevent saving an invalid document. If you want to
handle validation manually, and be able to save objects which don&#39;t pass
validation, you can set <code>validateBeforeSave</code> to false.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
schema.set(<span class="hljs-string">'validateBeforeSave'</span>, <span class="hljs-literal">false</span>);
schema.path(<span class="hljs-string">'name'</span>).validate(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">return</span> v != <span class="hljs-literal">null</span>;
});
<span class="hljs-keyword">var</span> M = mongoose.model(<span class="hljs-string">'Person'</span>, schema);
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> M({ name: <span class="hljs-literal">null</span> });
m.validate(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
    <span class="hljs-built_in">console</span>.log(err); <span class="hljs-comment">// Will tell you that null is not allowed.</span>
});
m.save(); <span class="hljs-comment">// Succeeds despite being invalid</span>
</code></pre>
<h3 id="versionKey"><a href="#versionKey">option: versionKey</a></h3>

<p><code>versionKey</code> 是 Mongoose 在文件创建时自动设定的。
这个值包含文件的内部<a href="http://aaronheckmann.tumblr.com/post/48943525537/mongoose-v3-part-1-versioning">修订号</a>。
<code>versionKey</code> 是一个字符串，代表版本号的属性名，
默认值为 <code>__v</code>。如果这个值与你的计划冲突，你可以设定为其他名称：</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-string">'string'</span> });
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, schema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing({ name: <span class="hljs-string">'mongoose v3'</span> });
thing.save(); <span class="hljs-comment">// { __v: 0, name: 'mongoose v3' }</span>

<span class="hljs-comment">// customized versionKey</span>
<span class="hljs-keyword">new</span> Schema({..}, { versionKey: <span class="hljs-string">'_somethingElse'</span> })
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, schema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing({ name: <span class="hljs-string">'mongoose v3'</span> });
thing.save(); <span class="hljs-comment">// { _somethingElse: 0, name: 'mongoose v3' }</span>
</code></pre>
<p>你也可以赋值为 <code>false</code> 禁用 <code>versionKey</code>。
<em>你不应该随便禁用这个功能，<a href="http://aaronheckmann.tumblr.com/post/48943525537/mongoose-v3-part-1-versioning">除非你清楚知道这有什么影响</a>。</em></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({..}, { versionKey: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, schema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing({ name: <span class="hljs-string">'no versioning please'</span> });
thing.save(); <span class="hljs-comment">// { name: 'no versioning please' }</span>
</code></pre>
<h3 id="collation"><a href="#collation">option: collation</a></h3>

<p>为 查询（query）和 聚合（aggregation）设置 <a href="https://docs.mongodb.com/manual/reference/collation/">collation</a>。
这里有一份友好的 <a href="http://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations">collation 指南</a>。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({
  name: <span class="hljs-built_in">String</span>
}, { collation: { locale: <span class="hljs-string">'en_US'</span>, strength: <span class="hljs-number">1</span> } });

<span class="hljs-keyword">var</span> MyModel = db.model(<span class="hljs-string">'MyModel'</span>, schema);

MyModel.create([{ name: <span class="hljs-string">'val'</span> }, { name: <span class="hljs-string">'Val'</span> }]).
  then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> MyModel.find({ name: <span class="hljs-string">'val'</span> });
  }).
  then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">docs</span>) </span>{
    <span class="hljs-comment">// `docs` will contain both docs, because `strength: 1` means</span>
    <span class="hljs-comment">// MongoDB will ignore case when matching.</span>
  });
</code></pre>
<h3 id="skipVersioning"><a href="#skipVersioning">option: skipVersioning</a></h3>

<p><code>skipVersioning</code> allows excluding paths from versioning (i.e., the internal
revision will not be incremented even if these paths are updated). DO NOT
do this unless you know what you&#39;re doing. For subdocuments, include this
on the parent document using the fully qualified path.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> Schema({..}, { skipVersioning: { dontVersionMe: <span class="hljs-literal">true</span> } });
thing.dontVersionMe.push(<span class="hljs-string">'hey'</span>);
thing.save(); <span class="hljs-comment">// version is not incremented</span>
</code></pre>
<h3 id="timestamps"><a href="#timestamps">option: timestamps</a></h3>

<p>如果设置了 <code>timestamps</code> 选项, mongoose 会在你的 schema 自动添加 <code>createdAt</code> 和 <code>updatedAt</code> 字段，
其类型为 <a href="./api.html#schema-date-js">Date</a>。</p>
<p>这两个字段的默认名是 <code>createdAt</code> 和 <code>updatedAt</code>， 你可以通过设定
<code>timestamps.createdAt</code> 和 <code>timestamps.updatedAt</code> 自定义字段名称。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> thingSchema = <span class="hljs-keyword">new</span> Schema({..}, { timestamps: { createdAt: <span class="hljs-string">'created_at'</span> } });
<span class="hljs-keyword">var</span> Thing = mongoose.model(<span class="hljs-string">'Thing'</span>, thingSchema);
<span class="hljs-keyword">var</span> thing = <span class="hljs-keyword">new</span> Thing();
thing.save(); <span class="hljs-comment">// `created_at` &amp; `updatedAt` will be included</span>
</code></pre>
<h3 id="useNestedStrict"><a href="#useNestedStrict">option: useNestedStrict</a></h3>

<p>在 mongoose4 中，<code>update()</code> 和 <code>findOneAndUpdate()</code>只检查顶层
schema 的严格模式设定。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> childSchema = <span class="hljs-keyword">new</span> Schema({}, { strict: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> parentSchema = <span class="hljs-keyword">new</span> Schema({ child: childSchema }, { strict: <span class="hljs-string">'throw'</span> });
<span class="hljs-keyword">var</span> Parent = mongoose.model(<span class="hljs-string">'Parent'</span>, parentSchema);
Parent.update({}, { <span class="hljs-string">'child.name'</span>: <span class="hljs-string">'Luke Skywalker'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  <span class="hljs-comment">// 报错！原因是父Schema设定为`strict: throw`，但是因为只检查顶层，导致</span>
  <span class="hljs-comment">// 子Schema的 `strict: false` 遭到无情忽视</span>
});

<span class="hljs-keyword">var</span> update = { <span class="hljs-string">'child.name'</span>: <span class="hljs-string">'Luke Skywalker'</span> };
<span class="hljs-keyword">var</span> opts = { strict: <span class="hljs-literal">false</span> };
Parent.update({}, update, opts, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  <span class="hljs-comment">// 这样可以，因为重写了父Schema的 strict 选项</span>
});
</code></pre>
<p>如果你把 <code>useNestedStrict</code> 设为 true，mongoose 就不会忽略嵌套的 strict 设定。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> childSchema = <span class="hljs-keyword">new</span> Schema({}, { strict: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">var</span> parentSchema = <span class="hljs-keyword">new</span> Schema({ child: childSchema },
  { strict: <span class="hljs-string">'throw'</span>, useNestedStrict: <span class="hljs-literal">true</span> });
<span class="hljs-keyword">var</span> Parent = mongoose.model(<span class="hljs-string">'Parent'</span>, parentSchema);
Parent.update({}, { <span class="hljs-string">'child.name'</span>: <span class="hljs-string">'Luke Skywalker'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  <span class="hljs-comment">// Works!</span>
});
</code></pre>
<h3 id="plugins"><a href="#plugins">Pluggable</a></h3>

<p>Schemas 是 <a href="./plugins.html">pluggable（可扩展的）</a>，
我们可以打包插件分享到社区，或者复用于自己的项目。</p>
<h3 id="next">下一步</h3>

<p>现在我们了解了 <code>Schemas</code>，我们接着了解一下 <a href="/docs/schematypes.html">SchemaTypes</a>。</p>
</div></div><script type="text/javascript">!function(name,path,ctx){
  var latest,prev=name!=='Keen'&&window.Keen?window.Keen:false;ctx[name]=ctx[name]||{ready:function(fn){var h=document.getElementsByTagName('head')[0],s=document.createElement('script'),w=window,loaded;s.onload=s.onerror=s.onreadystatechange=function(){if((s.readyState&&!(/^c|loade/.test(s.readyState)))||loaded){return}s.onload=s.onreadystatechange=null;loaded=1;latest=w.Keen;if(prev){w.Keen=prev}else{try{delete w.Keen}catch(e){w.Keen=void 0}}ctx[name]=latest;ctx[name].ready(fn)};s.async=1;s.src=path;h.parentNode.insertBefore(s,h)}}
}('KeenAsync','https://d26b395fwzu5fz.cloudfront.net/keen-tracking-1.1.3.min.js',this);

KeenAsync.ready(function(){
  // Configure a client instance
  var client = new KeenAsync({
    projectId: '59aad9cbc9e77c0001ce1b32',
    writeKey: '4B38B0046086885E425D368BFAEAD8FD0D4F2DC2FA2F936FDE058D79508AEFAD9886BC020B96520823BB9C8241D9D9BCFDC0EF52E6033BD89D06E4B24FC13AE955896BF443406269A84DD009CEB5862DCEC944874DB2107FD648DA91ADC1E6DE'
  });

  client.recordEvent('pageView', {
    host: window.location.host,
    pathname: window.location.pathname,
    hash: window.location.hash
  });
});</script><script type="text/javascript">(function (window, document) {
  var layout   = document.getElementById('layout'),
      menu     = document.getElementById('menu'),
      menuLink = document.getElementById('menuLink'),
      content  = document.getElementById('content');

  function toggleClass(element, className) {
      var classes = element.className.split(/\s+/),
          length = classes.length,
          i = 0;

      for(; i < length; i++) {
        if (classes[i] === className) {
          classes.splice(i, 1);
          break;
        }
      }
      // The className is not found
      if (length === classes.length) {
          classes.push(className);
      }

      element.className = classes.join(' ');
  }

  function toggleAll(e) {
      var active = 'active';

      e.preventDefault();
      toggleClass(layout, active);
      toggleClass(menu, active);
      toggleClass(menuLink, active);
  }

  menuLink.onclick = function (e) {
      toggleAll(e);
  };

  content.onclick = function(e) {
      if (menu.className.indexOf('active') !== -1) {
          toggleAll(e);
      }
  };

}(this, this.document));</script></div></body></html>